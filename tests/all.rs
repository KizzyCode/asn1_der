#[macro_use] extern crate asn1_der;
#[macro_use] extern crate etrace;

mod tests {
	use std::fmt::Debug;
	use super::asn1_der::{ Asn1DerError, DerObject, FromDerObject, IntoDerObject, FromDerEncoded, IntoDerEncoded };
	#[cfg(feature="map")] use super::{ asn1_der::map::DerMapOrdered, std::{ cmp::Ordering, collections::HashMap } };
	
	
	#[test]
	fn der_object_ok() {
		let generics = [
			// Some valid generic-objects
			(b"\x05\x00".as_ref(), (0x05, b"".as_ref())), // Null-object
			(b"\x04\x02\x37\xe4", (0x04, b"\x37\xe4".as_ref())),
			(b"\x04\x7F\x33\x0e\x8d\xb9\x1b\x33\x21\x5c\x0e\x53\x3f\xd2\x8e\x34\xcc\x8b\x09\xa8\x08\x87\x7d\xc7\xd8\x27\x41\x93\x04\x31\xbd\x09\xd0\xd6\xf3\x1a\x68\x7d\x40\x60\x12\x6f\x0c\xe0\x36\x0a\xcf\x95\xde\x81\x2f\xa4\x2f\x62\xf6\x71\x97\xe0\x49\x60\x3b\x65\x74\x8f\xd2\x57\xe3\xc1\x61\x1d\xb4\x54\xa4\x96\xa6\xb3\xf4\x3b\x27\xaa\x5a\xeb\xc9\x23\x58\x92\x1b\x27\x54\x79\xe6\x7c\xb1\x79\x83\x00\x5b\x08\x5b\x85\x2f\x0c\x2f\x8d\x34\x47\x2c\xa4\x70\xdf\xb0\xa3\x9b\x61\x33\x6d\xd3\x91\x84\x81\x97\x68\x67\x54\xb2\xee\x57\xfd\x84".as_ref(),
			 (0x04, b"\x33\x0e\x8d\xb9\x1b\x33\x21\x5c\x0e\x53\x3f\xd2\x8e\x34\xcc\x8b\x09\xa8\x08\x87\x7d\xc7\xd8\x27\x41\x93\x04\x31\xbd\x09\xd0\xd6\xf3\x1a\x68\x7d\x40\x60\x12\x6f\x0c\xe0\x36\x0a\xcf\x95\xde\x81\x2f\xa4\x2f\x62\xf6\x71\x97\xe0\x49\x60\x3b\x65\x74\x8f\xd2\x57\xe3\xc1\x61\x1d\xb4\x54\xa4\x96\xa6\xb3\xf4\x3b\x27\xaa\x5a\xeb\xc9\x23\x58\x92\x1b\x27\x54\x79\xe6\x7c\xb1\x79\x83\x00\x5b\x08\x5b\x85\x2f\x0c\x2f\x8d\x34\x47\x2c\xa4\x70\xdf\xb0\xa3\x9b\x61\x33\x6d\xd3\x91\x84\x81\x97\x68\x67\x54\xb2\xee\x57\xfd\x84".as_ref())),
			(b"\x04\x81\x80\xe7\x4b\xfa\xed\x07\x20\x14\x37\xef\xfc\x07\xf1\xbd\x1a\xc3\x7c\xb9\x99\xfe\x4d\xb8\x26\x7b\x6a\x6f\x03\xdd\x08\xaf\x0f\xb8\x4c\xa2\x79\xd2\xe5\x96\xde\xcd\xad\x1f\x4d\x41\xcf\x4a\x3a\x03\x43\xa6\x8d\xca\x20\xec\x07\x3c\x8d\x00\x16\xa0\x73\x14\x5f\x2f\xf9\x6e\x13\x7d\x9a\x4a\xe6\x81\xd0\xd9\x8f\x26\x7c\x1d\xd1\x7d\x47\xdb\x49\xc3\x0d\x03\xc3\x3d\xc9\x06\xf3\x1a\x22\x9c\xab\x5c\x2f\x3d\x1c\x4b\x73\x2d\x31\x9e\x8f\x4a\xe0\xaf\xaa\x99\xee\xea\x73\x48\x4e\x01\x94\x7e\x57\xd7\x1f\x2d\x82\xba\x0a\xb2\x43\x0f\xd3".as_ref(),
			 (0x04, b"\xe7\x4b\xfa\xed\x07\x20\x14\x37\xef\xfc\x07\xf1\xbd\x1a\xc3\x7c\xb9\x99\xfe\x4d\xb8\x26\x7b\x6a\x6f\x03\xdd\x08\xaf\x0f\xb8\x4c\xa2\x79\xd2\xe5\x96\xde\xcd\xad\x1f\x4d\x41\xcf\x4a\x3a\x03\x43\xa6\x8d\xca\x20\xec\x07\x3c\x8d\x00\x16\xa0\x73\x14\x5f\x2f\xf9\x6e\x13\x7d\x9a\x4a\xe6\x81\xd0\xd9\x8f\x26\x7c\x1d\xd1\x7d\x47\xdb\x49\xc3\x0d\x03\xc3\x3d\xc9\x06\xf3\x1a\x22\x9c\xab\x5c\x2f\x3d\x1c\x4b\x73\x2d\x31\x9e\x8f\x4a\xe0\xaf\xaa\x99\xee\xea\x73\x48\x4e\x01\x94\x7e\x57\xd7\x1f\x2d\x82\xba\x0a\xb2\x43\x0f\xd3".as_ref())),
		];
		generics.iter().for_each(|&(encoded, (tag, payload))| {
			// Test decoding
			let decoded = DerObject::with_der_encoded(encoded).expect("Failed to decode valid DER-object");
			assert_eq!(decoded.tag, tag);
			assert_eq!(decoded.payload, payload);
			// Test encoding
			let reencoded = decoded.into_der_encoded();
			assert_eq!(reencoded, encoded);
		})
	}
	#[test]
	fn der_object_err() {
		let generics = [
			// asn1_der::der_length::decode_length
			(b"\x04\x82\xff".as_ref(), Asn1DerError::NotEnoughBytes), // Length is too short
			(b"\x04\x81\x01\x7e".as_ref(), Asn1DerError::InvalidEncoding), // Complex length-encoding for < 128
			(b"\x04".as_ref(), Asn1DerError::NotEnoughBytes), // There is no length
			// asn1_der::Generic::from_der_encoded
			(b"".as_ref(), Asn1DerError::NotEnoughBytes), // No data present
			(b"\x04\x02\xff".as_ref(), Asn1DerError::NotEnoughBytes), // Payload is too short
		];
		generics.iter().for_each(|&(encoded, ref error)| {
			let decoding_err = DerObject::with_der_encoded(encoded).expect_err("Decoded invalid DER-object without error");
			assert_eq!(decoding_err.kind, *error);
		})
	}
	
	
	#[inline]
	fn typed_ok<T>(test_vectors: &[(&[u8], T)]) where T: FromDerObject + IntoDerObject + FromDerEncoded + IntoDerEncoded + Eq + Clone + Debug {
		test_vectors.iter().for_each(|&(encoded, ref expected)| {
			let decoded_object = {
				let decoded0 = DerObject::with_der_encoded(encoded).unwrap();
				let decoded1 = DerObject::from_der_encoded(encoded.to_vec()).unwrap();
				assert_eq!(decoded0, decoded1);
				decoded0
			};
			
			let plain = {
				let plain0 = T::from_der_object(decoded_object.clone()).unwrap();
				let plain1 = T::with_der_encoded(encoded).unwrap();
				let plain2 = T::from_der_encoded(encoded.to_vec()).unwrap();
				assert_eq!(plain0, plain1);
				assert_eq!(plain1, plain2);
				plain0
			};
			assert_eq!(&plain, expected);
			
			assert_eq!(plain.clone().into_der_object(), decoded_object);
			assert_eq!(plain.into_der_encoded(), encoded);
		})
	}
	#[inline]
	fn typed_err<T>(test_vectors: &[(&[u8], Asn1DerError)]) where T: FromDerObject + FromDerEncoded + Debug {
		test_vectors.iter().for_each(|&(encoded, ref error)| {
			let decoded = DerObject::with_der_encoded(encoded).unwrap();
			let decoding_err = {
				let decoding_err0 = T::from_der_object(decoded).unwrap_err();
				let decoding_err1 = T::with_der_encoded(encoded).unwrap_err();
				let decoding_err2 = T::from_der_encoded(encoded.to_vec()).unwrap_err();
				assert_eq!(decoding_err0.kind, decoding_err1.kind);
				assert_eq!(decoding_err1.kind, decoding_err2.kind);
				decoding_err0
			};
			assert_eq!(decoding_err.kind, *error);
		});
	}
	
	
	#[test]
	fn null_ok() {
		let test_vectors = [(b"\x05\x00".as_ref(), ())];
		typed_ok(&test_vectors);
	}
	#[test]
	fn null_err() {
		let test_vectors = [
			(b"\x06\x00".as_ref(), Asn1DerError::InvalidTag),
			(b"\x05\x01\x00".as_ref(), Asn1DerError::InvalidEncoding)
		];
		typed_err::<()>(&test_vectors);
	}
	
	
	#[test]
	fn bool_ok() {
		let test_vectors = [
			(b"\x01\x01\x00".as_ref(), false),
			(b"\x01\x01\xff".as_ref(), true)
		];
		typed_ok(&test_vectors);
	}
	#[test]
	fn bool_err() {
		let test_vectors = [
			(b"\x06\x00".as_ref(), Asn1DerError::InvalidTag),
			(b"\x01\x01\x17".as_ref(), Asn1DerError::InvalidEncoding),
			(b"\x01\x02\x00\x00".as_ref(), Asn1DerError::InvalidEncoding),
			(b"\x01\x02\xff\x00".as_ref(), Asn1DerError::InvalidEncoding),
			(b"\x01\x02\x17\x00".as_ref(), Asn1DerError::InvalidEncoding)
		];
		typed_err::<bool>(&test_vectors);
	}
	
	
	#[test]
	fn octet_string_ok() {
		let test_vectors = [
			(b"\x04\x02\x37\xe4".as_ref(), b"\x37\xe4".to_vec()),
			(b"\x04\x7F\x33\x0e\x8d\xb9\x1b\x33\x21\x5c\x0e\x53\x3f\xd2\x8e\x34\xcc\x8b\x09\xa8\x08\x87\x7d\xc7\xd8\x27\x41\x93\x04\x31\xbd\x09\xd0\xd6\xf3\x1a\x68\x7d\x40\x60\x12\x6f\x0c\xe0\x36\x0a\xcf\x95\xde\x81\x2f\xa4\x2f\x62\xf6\x71\x97\xe0\x49\x60\x3b\x65\x74\x8f\xd2\x57\xe3\xc1\x61\x1d\xb4\x54\xa4\x96\xa6\xb3\xf4\x3b\x27\xaa\x5a\xeb\xc9\x23\x58\x92\x1b\x27\x54\x79\xe6\x7c\xb1\x79\x83\x00\x5b\x08\x5b\x85\x2f\x0c\x2f\x8d\x34\x47\x2c\xa4\x70\xdf\xb0\xa3\x9b\x61\x33\x6d\xd3\x91\x84\x81\x97\x68\x67\x54\xb2\xee\x57\xfd\x84".as_ref(),
			 b"\x33\x0e\x8d\xb9\x1b\x33\x21\x5c\x0e\x53\x3f\xd2\x8e\x34\xcc\x8b\x09\xa8\x08\x87\x7d\xc7\xd8\x27\x41\x93\x04\x31\xbd\x09\xd0\xd6\xf3\x1a\x68\x7d\x40\x60\x12\x6f\x0c\xe0\x36\x0a\xcf\x95\xde\x81\x2f\xa4\x2f\x62\xf6\x71\x97\xe0\x49\x60\x3b\x65\x74\x8f\xd2\x57\xe3\xc1\x61\x1d\xb4\x54\xa4\x96\xa6\xb3\xf4\x3b\x27\xaa\x5a\xeb\xc9\x23\x58\x92\x1b\x27\x54\x79\xe6\x7c\xb1\x79\x83\x00\x5b\x08\x5b\x85\x2f\x0c\x2f\x8d\x34\x47\x2c\xa4\x70\xdf\xb0\xa3\x9b\x61\x33\x6d\xd3\x91\x84\x81\x97\x68\x67\x54\xb2\xee\x57\xfd\x84".to_vec()),
			(b"\x04\x81\x80\xe7\x4b\xfa\xed\x07\x20\x14\x37\xef\xfc\x07\xf1\xbd\x1a\xc3\x7c\xb9\x99\xfe\x4d\xb8\x26\x7b\x6a\x6f\x03\xdd\x08\xaf\x0f\xb8\x4c\xa2\x79\xd2\xe5\x96\xde\xcd\xad\x1f\x4d\x41\xcf\x4a\x3a\x03\x43\xa6\x8d\xca\x20\xec\x07\x3c\x8d\x00\x16\xa0\x73\x14\x5f\x2f\xf9\x6e\x13\x7d\x9a\x4a\xe6\x81\xd0\xd9\x8f\x26\x7c\x1d\xd1\x7d\x47\xdb\x49\xc3\x0d\x03\xc3\x3d\xc9\x06\xf3\x1a\x22\x9c\xab\x5c\x2f\x3d\x1c\x4b\x73\x2d\x31\x9e\x8f\x4a\xe0\xaf\xaa\x99\xee\xea\x73\x48\x4e\x01\x94\x7e\x57\xd7\x1f\x2d\x82\xba\x0a\xb2\x43\x0f\xd3".as_ref(),
			 b"\xe7\x4b\xfa\xed\x07\x20\x14\x37\xef\xfc\x07\xf1\xbd\x1a\xc3\x7c\xb9\x99\xfe\x4d\xb8\x26\x7b\x6a\x6f\x03\xdd\x08\xaf\x0f\xb8\x4c\xa2\x79\xd2\xe5\x96\xde\xcd\xad\x1f\x4d\x41\xcf\x4a\x3a\x03\x43\xa6\x8d\xca\x20\xec\x07\x3c\x8d\x00\x16\xa0\x73\x14\x5f\x2f\xf9\x6e\x13\x7d\x9a\x4a\xe6\x81\xd0\xd9\x8f\x26\x7c\x1d\xd1\x7d\x47\xdb\x49\xc3\x0d\x03\xc3\x3d\xc9\x06\xf3\x1a\x22\x9c\xab\x5c\x2f\x3d\x1c\x4b\x73\x2d\x31\x9e\x8f\x4a\xe0\xaf\xaa\x99\xee\xea\x73\x48\x4e\x01\x94\x7e\x57\xd7\x1f\x2d\x82\xba\x0a\xb2\x43\x0f\xd3".to_vec()),
		];
		typed_ok(&test_vectors);
	}
	#[test]
	fn octet_string_err() {
		let test_vectors = [(b"\x05\x02\x37\xe4".as_ref(), Asn1DerError::InvalidTag)];
		typed_err::<Vec<u8>>(&test_vectors);
	}
	
	
	#[test]
	fn utf8_string_ok() {
		let test_vectors = [(b"\x0c\x19\x53\x6f\x6d\x65\x20\x55\x54\x46\x2d\x38\x20\x45\x6d\x6f\x6a\x69\x20\xf0\x9f\x96\x96\xf0\x9f\x8f\xbd".as_ref(), "Some UTF-8 Emoji üññüèΩ".to_string())];
		typed_ok(&test_vectors);
	}
	#[test]
	fn utf8_string_err() {
		let test_vectors = [
			(b"\x0d\x19\x53\x6f\x6d\x65\x20\x55\x54\x46\x2d\x38\x20\x45\x6d\x6f\x6a\x69\x20\xf0\x9f\x96\x96\xf0\x9f\x8f\xbd".as_ref(), Asn1DerError::InvalidTag),
			(b"\x0c\x04\xf0\x28\x8c\x28".as_ref(), Asn1DerError::InvalidEncoding)
		];
		typed_err::<String>(&test_vectors);
	}
	
	
	#[test]
	fn integer_ok() {
		let test_vectors = [
			(b"\x02\x01\x00".as_ref(), 0u64),
			(b"\x02\x01\x07".as_ref(), 7u64),
			(b"\x02\x08\x7f\xf7\xd3\x17\xce\xf1\xa7\x26".as_ref(), 9221070861274031910u64),
			(b"\x02\x09\x00\x80\xa5\x4c\x7f\xe5\x0d\x84\xa0".as_ref(), 9269899520199460000u64),
			(b"\x02\x09\x00\xff\xff\xff\xff\xff\xff\xff\xff".as_ref(), 18446744073709551615u64)
		];
		typed_ok(&test_vectors);
	}
	#[test]
	fn integer_err() {
		let test_vectors = [
			(b"\x03\x01\x07".as_ref(), Asn1DerError::InvalidTag),
			(b"\x02\x00".as_ref(), Asn1DerError::InvalidEncoding),
			(b"\x02\x01\x87".as_ref(), Asn1DerError::Unsupported),
			(b"\x02\x09\x01\xe3\xa5\x4c\x7f\xe5\x0d\x84\xa0".as_ref(), Asn1DerError::Unsupported)
		];
		typed_err::<u64>(&test_vectors);
	}
	
	
	#[test]
	fn sequence_ok() {
		let test_vectors = [
			(b"\x30\x00".as_ref(), vec![]),
			(b"\x30\x04\x04\x02\x37\xe4".as_ref(), vec![DerObject::new(0x04, b"\x37\xe4".to_vec())]),
			(b"\x30\x81\x87\x04\x02\x37\xe4\x04\x81\x80\x72\x33\x0e\x8d\xb9\x1b\x33\x21\x5c\x0e\x53\x3f\xd2\x8e\x34\xcc\x8b\x09\xa8\x08\x87\x7d\xc7\xd8\x27\x41\x93\x04\x31\xbd\x09\xd0\xd6\xf3\x1a\x68\x7d\x40\x60\x12\x6f\x0c\xe0\x36\x0a\xcf\x95\xde\x81\x2f\xa4\x2f\x62\xf6\x71\x97\xe0\x49\x60\x3b\x65\x74\x8f\xd2\x57\xe3\xc1\x61\x1d\xb4\x54\xa4\x96\xa6\xb3\xf4\x3b\x27\xaa\x5a\xeb\xc9\x23\x58\x92\x1b\x27\x54\x79\xe6\x7c\xb1\x79\x83\x00\x5b\x08\x5b\x85\x2f\x0c\x2f\x8d\x34\x47\x2c\xa4\x70\xdf\xb0\xa3\x9b\x61\x33\x6d\xd3\x91\x84\x81\x97\x68\x67\x54\xb2\xee\x57\xfd\x84".as_ref(),
			 vec![DerObject::new(0x04, b"\x37\xe4".to_vec()), DerObject::new(0x04, b"\x72\x33\x0e\x8d\xb9\x1b\x33\x21\x5c\x0e\x53\x3f\xd2\x8e\x34\xcc\x8b\x09\xa8\x08\x87\x7d\xc7\xd8\x27\x41\x93\x04\x31\xbd\x09\xd0\xd6\xf3\x1a\x68\x7d\x40\x60\x12\x6f\x0c\xe0\x36\x0a\xcf\x95\xde\x81\x2f\xa4\x2f\x62\xf6\x71\x97\xe0\x49\x60\x3b\x65\x74\x8f\xd2\x57\xe3\xc1\x61\x1d\xb4\x54\xa4\x96\xa6\xb3\xf4\x3b\x27\xaa\x5a\xeb\xc9\x23\x58\x92\x1b\x27\x54\x79\xe6\x7c\xb1\x79\x83\x00\x5b\x08\x5b\x85\x2f\x0c\x2f\x8d\x34\x47\x2c\xa4\x70\xdf\xb0\xa3\x9b\x61\x33\x6d\xd3\x91\x84\x81\x97\x68\x67\x54\xb2\xee\x57\xfd\x84".to_vec())])
		];
		typed_ok(&test_vectors);
	}
	#[test]
	fn sequence_err() {
		let test_vectors = [
			(b"\x31\x00".as_ref(), Asn1DerError::InvalidTag),
			(b"\x30\x04\x05\x03\x37\xe4".as_ref(), Asn1DerError::NotEnoughBytes)
		];
		typed_err::<Vec<DerObject>>(&test_vectors);
	}
	
	
	#[cfg(feature="map")] #[test]
	fn der_ordered_ordering() {
		[
			// (left: 0, right: 1, result: 2)
			("Testolope", "Uestolope", Ordering::Less),
			("Testolope", "Testolope", Ordering::Equal),
			("Testolope", "testolope", Ordering::Less),
			("testolope", "Testolope", Ordering::Greater),
			("Testolope", "Testolop", Ordering::Greater),
			("Testolop", "Testolope", Ordering::Less)
		].iter().for_each(|t| {
			let ordering = t.0.to_string().ordering(&t.1.to_string());
			assert_eq!(ordering, t.2);
		})
	}
	#[cfg(feature="map")] #[test]
	fn map_ok() {
		macro_rules! map {
		    ($($key:expr => $value:expr),*) => ({
		    	let mut map = HashMap::new();
		    	$(map.insert($key, $value);)*;
		    	map
		    });
		}
		
		let test_vectors = [
			(b"\x30\x31\x0c\x03\x4e\x75\x6c\x02\x01\x00\x0c\x04\x4e\x75\x6c\x6c\x02\x01\x00\x0c\x03\x4f\x6e\x65\x02\x01\x01\x0c\x04\x6e\x75\x6c\x6c\x02\x01\x00\x0c\x02\x6f\x6e\x02\x01\x01\x0c\x03\x6f\x6e\x65\x02\x01\x01".as_ref(),
			 map!("Nul".to_string() => 0, "Null".to_string() => 0, "null".to_string() => 0, "One".to_string() => 1, "one".to_string() => 1, "on".to_string() => 1))
		];
		typed_ok(&test_vectors);
	}
	#[test]
	fn map_err() {
		let test_vectors = [
			(b"\x31\x00".as_ref(), Asn1DerError::InvalidTag),
			(b"\x30\x04\x05\x03\x37\xe4".as_ref(), Asn1DerError::NotEnoughBytes),
			(b"\x30\x2c\x02\x01\x00\x0c\x04\x4e\x75\x6c\x6c\x02\x01\x00\x0c\x03\x4f\x6e\x65\x02\x01\x01\x0c\x04\x6e\x75\x6c\x6c\x02\x01\x00\x0c\x02\x6f\x6e\x02\x01\x01\x0c\x03\x6f\x6e\x65\x02\x01\x01".as_ref(), Asn1DerError::InvalidEncoding)
		];
		typed_err::<HashMap<String, u64>>(&test_vectors);
	}
	
	
	#[test]
	fn impl_macro() {
		// Define inner struct
		#[derive(Debug, Clone, Eq, PartialEq)]
		struct Inner {
			integer: u64,
			boolean: bool,
			octet_string: Vec<u8>,
			utf8_string: String,
			null: (),
			sequence: Vec<Inner>,
			der_object: DerObject
		}
		impl Inner {
			pub fn new(num: u64) -> Self {
				Inner{
					integer: num, boolean: num % 2 == 0,
					octet_string: b"Testolope (octet_string)".to_vec(), utf8_string: format!("Inner {}", num),
					null: (), sequence: vec![], der_object: DerObject::new(0x14, b"Testolope (der_object)".to_vec())
				}
			}
		}
		asn1_der_impl!(Inner{ integer, boolean, octet_string, utf8_string, null, sequence, der_object });
		
		// Define outer struct
		#[derive(Debug, Clone, Eq, PartialEq)]
		struct Outer {
			utf8_string: String,
			inner: Inner
		}
		asn1_der_impl!(Outer{ utf8_string, inner });
		
		// Create inner and outer
		let inner =  {
			let mut inner_0 = Inner::new(0);
			inner_0.sequence.push(Inner::new(1));
			inner_0.sequence.push(Inner::new(2));
			inner_0
		};
		let outer = Outer{ utf8_string: "Testolope".to_string(), inner };
		
		// Encode and compare
		let encoded = outer.clone().into_der_encoded();
		let expected = b"\x30\x81\xe2\x0c\x09\x54\x65\x73\x74\x6f\x6c\x6f\x70\x65\x30\x81\xd4\x02\x01\x00\x01\x01\xff\x04\x18\x54\x65\x73\x74\x6f\x6c\x6f\x70\x65\x20\x28\x6f\x63\x74\x65\x74\x5f\x73\x74\x72\x69\x6e\x67\x29\x0c\x07\x49\x6e\x6e\x65\x72\x20\x30\x05\x00\x30\x81\x8e\x30\x45\x02\x01\x01\x01\x01\x00\x04\x18\x54\x65\x73\x74\x6f\x6c\x6f\x70\x65\x20\x28\x6f\x63\x74\x65\x74\x5f\x73\x74\x72\x69\x6e\x67\x29\x0c\x07\x49\x6e\x6e\x65\x72\x20\x31\x05\x00\x30\x00\x14\x16\x54\x65\x73\x74\x6f\x6c\x6f\x70\x65\x20\x28\x64\x65\x72\x5f\x6f\x62\x6a\x65\x63\x74\x29\x30\x45\x02\x01\x02\x01\x01\xff\x04\x18\x54\x65\x73\x74\x6f\x6c\x6f\x70\x65\x20\x28\x6f\x63\x74\x65\x74\x5f\x73\x74\x72\x69\x6e\x67\x29\x0c\x07\x49\x6e\x6e\x65\x72\x20\x32\x05\x00\x30\x00\x14\x16\x54\x65\x73\x74\x6f\x6c\x6f\x70\x65\x20\x28\x64\x65\x72\x5f\x6f\x62\x6a\x65\x63\x74\x29\x14\x16\x54\x65\x73\x74\x6f\x6c\x6f\x70\x65\x20\x28\x64\x65\x72\x5f\x6f\x62\x6a\x65\x63\x74\x29".as_ref();
		assert_eq!(encoded, expected);
		
		// Decode
		let decoded = Outer::from_der_encoded(encoded).unwrap();
		assert_eq!(decoded, outer);
	}
}